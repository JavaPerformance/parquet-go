package parquet

import (
	"io"

	"github.com/segmentio/parquet-go/bloom"
	"github.com/segmentio/parquet-go/deprecated"
	"github.com/segmentio/parquet-go/encoding"
	"github.com/segmentio/parquet-go/format"
	"github.com/segmentio/parquet-go/internal/bits"
)

type BloomFilter interface {
	Hash(Value) uint64

	Check(uint64) bool
}

// The BloomFilterConfig interface is a declarative representation of bloom filters
// used when configuring filters on a parquet writer.
type BloomFilterConfig interface {
	// Returns the path of the column that the filter applies to.
	Path() []string

	// NewEncoder constructs an encoder of bloom filter configured to hold the
	// given number of values and bits of filter per value.
	NewBloomBuffer(numValues, bitsPerValue int) BloomBuffer
}

// SplitBlockFilter constructs a split block bloom filter object for the column
// at the given path.
func SplitBlockFilter(path ...string) BloomFilterConfig { return splitBlockFilter(path) }

type splitBlockFilter []string

func (f *splitBlockFilter) Path() []string { return f }

func (f *splitBlockFilter) NewBloomBuffer(numValues int64, bitsPerValue int) BloomBuffer {
	return newSplitBlockEncoder(
		make(bloom.SplitBlockFilter, bloom.NumSplitBlocksOf(int(numValues), 10)),
	)
}

// Creates a header from the given bloom filter.
//
// For now there is only one type of filter supported, but we provide this
// function to suggest a model for extending the implementation if new filters
// are added to the parquet specs.
func bloomFilterHeader(filter BloomFilterConfig) (header format.BloomFilterHeader) {
	switch filter.(type) {
	case *splitBlockFilter:
		header.Algorithm.Block = &format.SplitBlockAlgorithm{}
	}
	header.Hash.XxHash = &format.XxHash{}
	header.Compression.Uncompressed = &format.BloomFilterUncompressed{}
	return header
}

func searchBloomFilter(filters []BloomFilterConfig, path columnPath) Filter {
	for _, f := range filters {
		if path.equal(f.Path()) {
			return f
		}
	}
	return nil
}

// BloomBuffer is an extension of the encoding.Encoder interface based on
// a bloom filter.
//
// Values written to the encoder are inserted into the filter. The state of the
// filter can be tested by accessing it via the Filter method, or serialized by
// accessing the underlying byte array calling the Bytes method.
type BloomBuffer interface {
	encoding.Encoder

	// Returns the bloom filter generated by this encoder as an array of bytes.
	Bytes() []byte

	// Inserts a new value in the bloom buffer.
	Encode(value []byte) error
}

func newSplitBlockEncoder(filter SplitBlockFilter) *splitBlockBuffer {
	// TODO: currently the hashing function used in parquet bloom filter is
	// always XXH64. This API does not allow configuring the hashing function,
	// which could become an issue if more hashing algorithms become available
	// in the future.
	//
	// Depending on how we do it, introducing an abstraction layer for the hash
	// function can have a measurable runtime cost.
	return &splitBlockBuffer{filter: filter}
}

// splitBlockBuffer is an adapter type which implements the encoding.Encoder
// interface on top of a bloom filter.
type splitBlockBuffer struct {
	filter SplitBlockFilter
}

func (e *splitBlockBuffer) Reset(io.Writer) {
	e.filter.Reset()
}

func (e *splitBlockBuffer) SetBitWidth(int) {
}

func (e *splitBlockBuffer) EncodeBoolean(data []bool) error {
	return e.EncodeFixedLenByteArray(1, bits.BoolToBytes(data))
}

func (e *splitBlockBuffer) EncodeInt8(data []int8) error {
	return e.EncodeFixedLenByteArray(1, bits.Int8ToBytes(data))
}

func (e *splitBlockBuffer) EncodeInt16(data []int16) error {
	return e.EncodeFixedLenByteArray(2, bits.Int16ToBytes(data))
}

func (e *splitBlockBuffer) EncodeInt32(data []int32) error {
	return e.EncodeFixedLenByteArray(4, bits.Int32ToBytes(data))
}

func (e *splitBlockBuffer) EncodeInt64(data []int64) error {
	return e.EncodeFixedLenByteArray(8, bits.Int64ToBytes(data))
}

func (e *splitBlockBuffer) EncodeInt96(data []deprecated.Int96) error {
	return e.EncodeFixedLenByteArray(12, deprecated.Int96ToBytes(data))
}

func (e *splitBlockBuffer) EncodeFloat(data []float32) error {
	return e.EncodeFixedLenByteArray(4, bits.Float32ToBytes(data))
}

func (e *splitBlockBuffer) EncodeDouble(data []float64) error {
	return e.EncodeFixedLenByteArray(8, bits.Float64ToBytes(data))
}

func (e *splitBlockBuffer) EncodeByteArray(data encoding.ByteArrayList) error {
	data.Range(func(v []byte) bool { e.filter.Insert(xxhash.Sum64(v)); return true })
	return nil
}

func (e *splitBlockBuffer) EncodeFixedLenByteArray(size int, data []byte) error {
	for i, j := 0, size; j <= len(data); {
		e.filter.Insert(xxhash.Sum64(data[i:j]))
		i += size
		j += size
	}
	return nil
}

func (e *splitBlockBuffer) Encode(value []byte) error {
	e.filter.Insert(xxhash.Sum64(value))
	return nil
}
