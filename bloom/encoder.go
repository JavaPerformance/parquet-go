package bloom

import (
	"io"

	"github.com/cespare/xxhash/v2"
	"github.com/segmentio/parquet-go/deprecated"
	"github.com/segmentio/parquet-go/encoding"
	"github.com/segmentio/parquet-go/internal/bits"
)

// Encoder is an extension of the encoding.Encoder interface based on a bloom
// filter.
//
// Values written to the encoder are inserted into the filter. The state of the
// filter can be tested by accessing it via the Filter method, or serialized by
// accessing the underlying byte array calling the Bytes method.
type Encoder interface {
	encoding.Encoder

	// Inserts a new value in the bloom buffer.
	Encode(value []byte) error

	// Returns the bloom filter generated by this encoder as an array of bytes.
	Bytes() []byte

	// Returns the bloom filter generated by this encoder as a Filter value.
	Filter() Filter
}

// NewSplitBlockEncoder constructs an encoder from a split block bloom filter.
func NewSplitBlockEncoder(filter SplitBlockFilter) Encoder {
	// TODO: currently the hashing function used in parquet bloom filter is
	// always XXH64. This API does not allow configuring the hashing function,
	// which could become an issue if more hashing algorithms become available
	// in the future.
	//
	// Depending on how we do it, introducing an abstraction layer for the hash
	// function can have a measurable runtime cost.
	//
	// We should revisit how we want to allow for extensions before releasing
	// v1.0 of the package.
	return &splitBlockEncoder{filter: filter}
}

// splitBlockEncoder is an adapter type which implements the encoding.Encoder
// interface on top of a bloom filter.
type splitBlockEncoder struct {
	filter SplitBlockFilter
}

func (e *splitBlockEncoder) Bytes() []byte {
	return e.filter.Bytes()
}

func (e *splitBlockEncoder) Filter() Filter {
	return &e.filter
}

func (e *splitBlockEncoder) Reset(io.Writer) {
	e.filter.Reset()
}

func (e *splitBlockEncoder) SetBitWidth(int) {
}

func (e *splitBlockEncoder) EncodeBoolean(data []bool) error {
	return e.EncodeFixedLenByteArray(1, bits.BoolToBytes(data))
}

func (e *splitBlockEncoder) EncodeInt8(data []int8) error {
	return e.EncodeFixedLenByteArray(1, bits.Int8ToBytes(data))
}

func (e *splitBlockEncoder) EncodeInt16(data []int16) error {
	return e.EncodeFixedLenByteArray(2, bits.Int16ToBytes(data))
}

func (e *splitBlockEncoder) EncodeInt32(data []int32) error {
	return e.EncodeFixedLenByteArray(4, bits.Int32ToBytes(data))
}

func (e *splitBlockEncoder) EncodeInt64(data []int64) error {
	return e.EncodeFixedLenByteArray(8, bits.Int64ToBytes(data))
}

func (e *splitBlockEncoder) EncodeInt96(data []deprecated.Int96) error {
	return e.EncodeFixedLenByteArray(12, deprecated.Int96ToBytes(data))
}

func (e *splitBlockEncoder) EncodeFloat(data []float32) error {
	return e.EncodeFixedLenByteArray(4, bits.Float32ToBytes(data))
}

func (e *splitBlockEncoder) EncodeDouble(data []float64) error {
	return e.EncodeFixedLenByteArray(8, bits.Float64ToBytes(data))
}

func (e *splitBlockEncoder) EncodeByteArray(data encoding.ByteArrayList) error {
	data.Range(func(v []byte) bool { e.filter.Insert(xxhash.Sum64(v)); return true })
	return nil
}

func (e *splitBlockEncoder) EncodeFixedLenByteArray(size int, data []byte) error {
	for i, j := 0, size; j <= len(data); {
		e.filter.Insert(xxhash.Sum64(data[i:j]))
		i += size
		j += size
	}
	return nil
}

func (e *splitBlockEncoder) Encode(value []byte) error {
	e.filter.Insert(xxhash.Sum64(value))
	return nil
}
